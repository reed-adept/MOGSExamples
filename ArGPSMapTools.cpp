
#include "ArGPSMapTools.h"
#include <assert.h>

AREXPORT ArGPSMapTools::ArGPSMapTools(ArGPS *gps, ArRobot* robot, ArServerHandlerCommands *commandServer, ArMap *map, ArServerHandlerPopup *popupServer) :
  myGPS(gps),
  myMap(map),
  myRobot(robot),
  myPopupServer(popupServer),
  myLastGoalNum(0),
  myHaveMapGPSCoords(false),
  myForbiddenLineStarted(false),
  myObstacleLineStarted(false),
  myStartNewMapCB(this, &ArGPSMapTools::startNewMap),
  myAddGoalHereCB(this, &ArGPSMapTools::addGoalHere),
  mySetOriginCB(this, &ArGPSMapTools::setOrigin),
  myStartForbiddenLineCB(this, &ArGPSMapTools::startForbiddenLine),
  myEndForbiddenLineCB(this, &ArGPSMapTools::endForbiddenLine),
  myStartObstacleLineCB(this, &ArGPSMapTools::startObstacleLine),
  myEndObstacleLineCB(this, &ArGPSMapTools::endObstacleLine),
  myReloadMapFileCB(this, &ArGPSMapTools::reloadMapFile)
{
  commandServer->addStringCommand("Map:startNewMap", "Start a new map using current GPS position as origin. Provide map name (required)", &myStartNewMapCB);
  commandServer->addStringCommand("Map:addGoalHere", "Modify the map to include a goal at the current GPS location. Provide goal name (optional)", &myAddGoalHereCB);
  commandServer->addCommand("Map:setMapOriginHere", "Set the georeference point for map center (origin) at the current GPS position to the map. Only use this command if the robot is at the map center point (origin of map). Use this to add a georeference point to a map generated by laser scanning and processing.", &mySetOriginCB);
  commandServer->addCommand("Map:forbiddenLineStart", "Begin a new forbidden line", &myStartForbiddenLineCB);
  commandServer->addCommand("Map:forbiddenLineEnd", "End a forbidden line that was started with forbiddenLineStart", &myEndForbiddenLineCB);
  commandServer->addCommand("Map:obstacleLineStart", "Begin a new obstacle line", &myStartObstacleLineCB);
  commandServer->addCommand("Map:obstacleLineEnd", "End a obstacle line that was started with obstacleLineStart", &myEndObstacleLineCB);
  commandServer->addCommand("Map:reloadFile", "Reload map from its file on the robot", &myReloadMapFileCB);
}

bool ArGPSMapTools::checkGPS(const std::string &action)
{
  if(!myGPS) {
    ArLog::log(ArLog::Terse, "ArGPSMapTools: error %s: NULL GPS object!", action.c_str());
    return false;
  }
  if(!myGPS->havePosition()) {
    ArLog::log(ArLog::Terse, "ArGPSMapTools: error %s: GPS doesn't have a valid position.", action.c_str());
    return false;
  }
  ArLog::log(ArLog::Normal, "ArGPSMapTools: %s at GPS position (lat=%f, lon=%f, alt=%f)  Robot pos is (x=%.2f, y=%.2f). HDOP is %f. Map origin is (%f, %f, %f)", 
    action.c_str(), myGPS->getLatitude(), myGPS->getLongitude(), myGPS->getAltitude(), 
    myRobot->getX(), myRobot->getY(),
    myGPS->haveHDOP() ? myGPS->getHDOP() : 0.0,
    myMap->getOriginLatLong().getX(), myMap->getOriginLatLong().getY(), myMap->getOriginAltitude()
  );
  return true;
}

bool ArGPSMapTools::checkMap(const std::string& action)
{
  if(!myMap) {
    ArLog::log(ArLog::Terse, "ArGPSMapTools: error %s: NULL map", action.c_str());
    return false;
  }
  if(strlen(myMap->getFileName()) == 0) {
    ArLog::log(ArLog::Terse, "ArGPSMapTools: error %s: no map file name", action.c_str());
    return false;
  }
  return true;
}

void ArGPSMapTools::startNewMap(ArArgumentBuilder *args)
{
  std::string filename = args->getFullString();
  if(filename.rfind(".map") == filename.npos)
    filename += ".map"; 
  ArLog::log(ArLog::Normal, "ArGPSMapTools: starting new map with name \"%s\".", filename.c_str());
  if(!checkGPS("starting new map")) return;
  myMap->lock();
  myMap->clear();
  myMap->writeFile(filename.c_str(), true);
  myMap->readFileAndChangeConfig(filename.c_str());
  myMap->unlock();
  setOrigin();
}

void ArGPSMapTools::resetMapCoords(const ArLLACoords& mapOrigin)
{
  myMapGPSCoords = ArMapGPSCoords(mapOrigin);
  myHaveMapGPSCoords = true;
}

void ArGPSMapTools::setOrigin()
{
  if(!checkGPS("setting map origin")) return;
  if(!checkMap("setting map origin")) return;
  if(myRobot)
  {
    ArLog::log(ArLog::Normal, "ArGPSMapTools: Resetting robot odometric position to 0,0,0.");
    myRobot->moveTo(0,0,0);
    myRobot->com(ArCommands::SIM_RESET);
  }
  if(myMap->hasOriginLatLongAlt())
  {
    ArLog::log(ArLog::Terse, "ArGPSMapTools: setting map origin: Warning: Map already has an origin point, it will be replaced by current position.");
  }
  myOrigin = ArLLACoords(myGPS->getLatitude(), myGPS->getLongitude(), myGPS->getAltitude());
  resetMapCoords(myOrigin);
  myMap->lock();
  myMap->setOriginLatLongAlt(true, ArPose(myGPS->getLatitude(), myGPS->getLongitude()), myGPS->getAltitude());
  myMap->writeFile(myMap->getFileName(), true);
  myMap->unlock();
  reloadMapFile();
}

ArPose ArGPSMapTools::getCurrentPosFromGPS()
{
  ArLLACoords gpsCoords(myGPS->getLatitude(), myGPS->getLongitude(), myGPS->getAltitude());
  double x, y, z;
  x = y = z = NAN;
  // XXX need to have previously saved origin in myMapGPSCoords; either recreate
  // here each time, or reset whenever a new map is either created or loaded
  // elsewhere, and in ctor if there is a map in arnl.
  if(!myHaveMapGPSCoords)
  {
    // get origin from ArMap
    resetMapCoords(
  }
  
  myMapGPSCoords.convertLLA2MapCoords(gpsCoords, x, y, z);
  return ArPose(x, y);
}
  

void ArGPSMapTools::addGoalHere(ArArgumentBuilder *args)
{
  if(!checkGPS("adding goal")) return;
  if(!checkMap("adding goal")) return;
  ArPose p = getCurrentPosFromGPS();
  ArLog::log(ArLog::Normal, "ArGPSMapTools: Adding goal %s in map at GPS position (x=%.2f, y=%.2f)", args->getFullString(), p.getX(), p.getY());
  myMap->lock();
  ArMapObject *newobj;
  myMap->getMapObjects()->push_back(newobj = new ArMapObject("Goal", p, args->getFullString(), "ICON", args->getFullString(), false, ArPose(0, 0), ArPose(0, 0)));
  printf("\tnew map object is:\n\t%s\n", newobj->toString());
  newobj->log();
  myMap->writeFile(myMap->getFileName(), true);
  myMap->unlock();
  reloadMapFile();
}

void ArGPSMapTools::startForbiddenLine()
{
  if(!checkGPS("starting forbidden line")) return;
  if(!checkMap("starting forbidden line")) return;
  if(myForbiddenLineStarted)
    endForbiddenLine();
  myForbiddenLineStart = getCurrentPosFromGPS();
  ArLog::log(ArLog::Normal, "ArGPSMapTools: Started forbidden line at %f, %f.", myForbiddenLineStart.getX(), myForbiddenLineStart.getY());
  myForbiddenLineStarted = true;
}

void ArGPSMapTools::endForbiddenLine()
{
  if(!myForbiddenLineStarted) return;
  if(!checkGPS("ending forbidden line")) return;
  if(!checkMap("ending forbidden line")) return;
  ArPose endpos = getCurrentPosFromGPS();
  ArLog::log(ArLog::Normal, "ArGPSMapTools: Ended forbidden line at %f, %f", endpos.getX(), endpos.getY());
  ArMapObject* obj = new ArMapObject("ForbiddenLine", myForbiddenLineStart, "", "ICON", "", true, myForbiddenLineStart, endpos);
  myMap->lock();
  myMap->getMapObjects()->push_back(obj);
  myMap->writeFile(myMap->getFileName(), true);
  myMap->unlock();
  myForbiddenLineStarted = false;
  reloadMapFile();
}

void ArGPSMapTools::startObstacleLine()
{
  if(!checkGPS("starting obstacle line")) return;
  if(!checkMap("starting obstacle line")) return;
  if(myObstacleLineStarted)
    endObstacleLine();
  myObstacleLineStart = getCurrentPosFromGPS();
  ArLog::log(ArLog::Normal, "ArGPSMapTools: Started obstacle line at %f, %f.", myObstacleLineStart.getX(), myObstacleLineStart.getY());
  myObstacleLineStarted = true;
}

void ArGPSMapTools::endObstacleLine()
{
  if(!myObstacleLineStarted) return;
  if(!checkGPS("ending obstacle line")) return;
  if(!checkMap("ending obstacle line")) return;
  ArPose endpos = getCurrentPosFromGPS();
  ArLog::log(ArLog::Normal, "ArGPSMapTools: Ended obstacle line at %f, %f", endpos.getX(), endpos.getY());
  ArLineSegment line(myObstacleLineStart, endpos);
  myMap->lock();
  std::vector<ArLineSegment>* lines = myMap->getLines();
  lines->push_back(line);
  myMap->setLines(lines);
  myMap->writeFile(myMap->getFileName(), true);
  myMap->unlock();
  myObstacleLineStarted = false;
  reloadMapFile();
}

void ArGPSMapTools::reloadMapFile()
{
  myMap->refresh();
  myMap->readFile(myMap->getFileName());
  myMap->mapChanged();
}
